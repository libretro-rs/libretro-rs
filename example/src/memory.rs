const GLYPH_SIZE: u16 = 5;

const MEMORY_SIZE: usize = 4096;

static FONT: [u8; 80] = [
  0xf0, 0x90, 0x90, 0x90, 0xf0, 0x20, 0x60, 0x20, 0x20, 0x70, 0xf0, 0x10, 0xf0, 0x80, 0xf0, 0xf0, //  0..16
  0x10, 0xf0, 0x10, 0xf0, 0x90, 0x90, 0xf0, 0x10, 0x10, 0xf0, 0x80, 0xf0, 0x10, 0xf0, 0xf0, 0x80, // 16..32
  0xf0, 0x90, 0xf0, 0xf0, 0x10, 0x20, 0x40, 0x40, 0xf0, 0x90, 0xf0, 0x90, 0xf0, 0xf0, 0x90, 0xf0, // 32..48
  0x10, 0xf0, 0xf0, 0x90, 0xf0, 0x90, 0x90, 0xe0, 0x90, 0xe0, 0x90, 0xe0, 0xf0, 0x80, 0x80, 0x80, // 48..64
  0xf0, 0xe0, 0x90, 0x90, 0x90, 0xe0, 0xf0, 0x80, 0xf0, 0x80, 0xf0, 0xf0, 0x80, 0xf0, 0x80, 0x80, // 64..80
];

pub struct Memory {
  data: [u8; MEMORY_SIZE],
}

impl Memory {
  pub fn new(game: &[u8]) -> Memory {
    let mut data = [0; MEMORY_SIZE];
    data[0x000..0x000 + FONT.len()].copy_from_slice(&FONT);
    data[0x200..0x200 + game.len()].copy_from_slice(game);

    Memory { data }
  }

  pub fn glyph_address(glyph: u16) -> u16 {
    glyph * GLYPH_SIZE
  }

  pub fn read_byte(&self, address: u16) -> u8 {
    self.data[(address & 0xfff) as usize]
  }

  pub fn write_byte(&mut self, address: u16, val: u8) {
    self.data[(address & 0xfff) as usize] = val
  }

  pub fn read_word(&self, address: u16) -> u16 {
    let upper = self.read_byte(address + 0) as u16;
    let lower = self.read_byte(address + 1) as u16;

    (upper << 8) | lower
  }
}
